# effective java 代码版
基于《effective java第三版》写的代码规范，包含书中重点内容，把effective java精简到代码
核心：减少代码缺陷、使得代码好维护、尽量在编译期发现问题

代码中根据《effective java》-xx可以搜到对应的章节介绍，比如要找17章节，则搜索
《effective java》-17

已完成章节：
<br />1、考虑用静态方法而不是构造器
<br />2、遇到多个构造器参数时，考虑用构建者
<br />3、使用私有构造器或者枚举类型来强化Singleton属性
<br />4、通过私有化构造器强化不可实例化的能力
<br />5、依赖注入优于硬连接资源（hardwiring resources）
<br />6、避免创建不必要的对象
<br />7、消除过时的对象引用
<br />8、避免使用终结方法和清理方法
<br />9、优先使用try-with-resources而不是try-finally
<br />10、覆盖equals方法时请遵守通用约定
<br />11、覆盖equals方法时总要覆盖hashCode方法
<br />12、始终要覆盖toString
<br />13、谨慎地覆盖clone
<br />14、考虑是否实现comparable
<br />15、最小化类和成员的可访问性
<br />16、在公有类中使用访问方法，而不是公有域
<br />17、使可变性最小化
<br />18、组合优先于继承
<br />19、若要设计继承，则提供文档说明，否则禁止继承
<br />20、接口优于抽象类
<br />21、为后代设计接口
<br />22、接口仅用来定义类型
<br />23、类层次结构优于标签类
<br />24、支持使用静态成员类而不是非静态类
<br />25、将源文件限制为单个顶级类
<br />26、不要使用原始类型
<br />27、消除不需要检查的警告
<br />28、列表优先于数组
<br />29、优先考虑泛型
<br />30、优先使用泛型方法
<br />31、使用限定通配符来增加 API 的灵活性
<br />32、合理地结合泛型和可变参数
<br />33、优先考虑类型安全的异构容器
<br />34、使用枚举类型替代整型常量
<br />35、使用实例属性替代序数
<br />36、使用 EnumSet 替代位属性
<br />37、使用EnumMap替代序数索引
<br />38、使用接口模拟可扩展的枚举
<br />39、注解优于命名模式
<br />40、始终使用 Override 注解
<br />41、使用标记接口定义类型
<br />42、lambda表达式优于匿名类
<br />43、方法引用优于 lambda 表达式
<br />44、优先使用标准的函数式接口
<br />45、明智审慎地使用 Stream
<br />46、优先考虑流中无副作用的函数
<br />47、优先使用Collection而不是Stream来作为方法的返回类型
<br />48、谨慎使用流并行
<br />49、检查参数有效性
<br />50、必要时进行防御性拷贝
<br />51、仔细设计方法签名
<br />52、明智审慎地使用重载
<br />53、明智审慎地使用可变参数
<br />54、返回空的数组或集合，不要返回 null
<br />55、明智审慎地返回 Optional
<br />56、为所有已公开的 API 元素编写文档注释
<br />57、最小化局部变量的作用域
<br />58、for-each 循环优于传统 for 循环
<br />59、了解并使用库
<br />60、若需要精确答案就应避免使用 float 和 double 类型